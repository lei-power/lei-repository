#### 远程调用后判断

```java
        BaseResp<List<String>>resp=produceFacadeClient.getListOfGisDkidByFarmId(snFarmId);
        if(!resp.isSuccess()){
        return BaseResp.returnResp(resp); //todo 为何不是返回 BaseResp.FairParmaError（“”xxxx）??
        }

        BaseResp<Map<Long, LandType>>landTypeBaseResp=produceFacadeClient.getAllListOfLandType();
        if(landTypeBaseResp.isSuccess()){
        landTypeMap=landTypeBaseResp.getObj();
        }// todo 只考虑成功后的操作，失败呢，往下走？
        BaseResp<GovernmentUser> governmentUserResp=governmentUserFacadeClient.get(user.getId());
        if(governmentUserResp.isSuccess()){
        record.setSyncUserName(governmentUserResp.getObj().getNickname());
        }// todo 只考虑成功后的操作，失败呢，往下走？
```

#### 非空判断

```java
           if(landTypeMap!=null){ //todo map 类型只判断是否为null list要判断size>0
        //  land.setLandTypeName(landTypeMap.get(req.getLandTypeId()) == null ? null : landTypeMap.get(req.getLandTypeId()).getLandTypeName());
        }
        if(landList!=null&&landList.size>0){ //todo list 的常用如何判断呢？？
        //  land.setLandTypeName(landTypeMap.get(req.getLandTypeId()) == null ? null : landTypeMap.get(req.getLandTypeId()).getLandTypeName());
        }
```

#### 大list分批插入

```java
        //方法一：stream流 利用分页方法
        if(result.size()>0){
                //一次500条
                int totalsize=500;
                int count=(result.size()+totalsize-1)/totalsize;
                //分成limit次发请求到数据库，in（）操作时   可以把多条数据分割成多组请求
                Stream.iterate(0,n->n+1).limit(count).forEach(i->{
                //获取 skip 跳过前面n个元素拿limit（xxx）xxx 个
                //doSomething();
                landMange.insetBatch(result.stream().skip(i*totalsize).limit(totalsize).collect(Collectors.toList()))
                });
                }

                // 方法二：传统循环
                //6、批量插入数据
                int listSize=insertList.size();
                int toIndex=1000;
                for(int i=0;i<insertList.size();i+=1000){ // todo 每次加1000 就只循环想要的 批量1000个
        if(i+1000>listSize){        //作用为toIndex最后没有toIndex条数据则剩余几条newList中就装几条
        toIndex=listSize-i;
        }
        List<Land> landList=insertList.subList(i,i+toIndex);
        produceFacadeClient.insertBatch(landList);
        }

```

### 字符串常用方法

#### 字符串分隔符拼接(用stringutils.join(List,separator:","))

```java
    snDkidList.isEmpty()?null:StringUtils.join(snDkidList,",")
```

### 加锁的写法(snkoudai里)

```java
        String key=LockCons.gisSyncLandToSn+gisfarmId;// todo 锁名要规范，放到常量类里
        try{
        RLock lock=redissonClient.getLock(key);// redisson 分布式锁用法
        boolean locked=lock.isLocked();
        log.info("syncLand--locked:{} -- key:{} ",locked,key);
        if(locked){
        log.error("syncLand--请勿频繁操作");
        return BaseResp.failByParamError("请勿频繁操作");
        }   // todo 先判断是否已加锁，做相应操作
        lock.tryLock(1,5,TimeUnit.SECONDS); // todo trylock 1s,自旋重试获取锁，5s释放锁时间，防止死锁 
        log.info("syncLand--locked--加锁成功--5秒-key:{}",key);
        1.xxx 2.xxxx return xxx;
        }catch(Exception e){
        log.error("gis主体同步地块失败",e);  //打印异常
        return BaseResp.failByParamError("gis主体同步地块失败"); //todo 这里有返回值？？？？？？？？
        }finally{
        RLock lock=redissonClient.getLock(key);
        if(lock!=null&&lock.isLocked()&&lock.isHeldByCurrentThread()){
        lock.unlock(); // todo 解锁判断比较复杂 锁可能为空，锁可能已经释放，锁可能被其他人锁定，这个会出现并发修改异常吗？？？
        //  lock.isHeldByCurrentThread() 判断是否是当前线程锁定                         
        }
        log.info("syncLand--locked--解锁成功--key:{}",key);
        }
        }
```

### 神农口袋 AOP 写法

```java
    @Pointcut("execution(public * com.za.*.biz.gov.controller..*.*(..))") public void logPointCut(){ }
    @Around("logPointCut()") public Object around(ProceedingJoinPoint point)throws Throwable{
        // 执行方法
        // todo 环绕通知在此处调用proceed()后,如果子服务有业务异常会直接步入这里并结束.所以需要捕获异常并抛出
        try{
        responseBody=point.proceed();
        }catch(Throwable throwable){
        exception=throwable;
        exceptionFlag=true;
        }
        // 执行时长(毫秒)
        int platformType=RequestUtils.getPlatformType(); // todo RequestUtils 请求工具类封装了很多方法，注意使用
        CurGovUser user=GovUserUtils.getUser();// 使用ThreadLocal 保证线程安全
        // 获取请求url
        HttpServletRequest request=RequestUtils.getRequest();
        String requestUrl=request.getRequestURI();
        // 获取请求ip
        String requestIp=RequestUtils.getIpAddress();
        // 获取请求方法
        String requestMethod=request.getMethod();
        // 获取请求参数;open服务接口都是使用json传参的post请求
        Object reqModel=RequestUtils.getRequestBodyParam(point);
        String requestBody=JsonUtils.toJson(reqModel);
        // 正常响应
        if(responseBody instanceof BaseResp){ // todo 神农口袋接口统一返回类 ，通过是否是其子类来判断是否是正常返回？？？ return BaseResp.fairParamError()???
        }
        List<String> filterRequestList=getFilterRequestUrlList(); // 过滤某些不需要记录的url，其实也拦截了，只是不写入数据库
        if(filterRequestList.contains(requestUrl)){// 存字符串数组
        if(exceptionFlag)throw exception; // 出异常了也要记录，所以前面抓了异常，这里抛
        return responseBody;
        }
        saveLog(responseCode,governmentSubjectId,requestUrl,requestIp,requestMethod,requestBody,responseBody,requestTime,platformType,accessToken,userId,loginName,respDesc); // todo 出异常了也要记录，所以前面抓了异常，这里抛
        if(exceptionFlag)throw exception;
        return responseBody;
        }
        }
```

### io流从classPath 获取

```java
ClassPathResource resource=new ClassPathResource("beans.xml");
        InputStream inputStream=resource.getInputStream();
```

### spring el表达式取值

```java
    @Value("#{'${gov.zagis.refdomain.list}'.split(',')}") 
    private List<String> refDomainList;

```

### 循环分批插入

```java
        int toIndex=1000;
        for(int i=0;i<tagList.size();i+=1000){
        if(i+1000>listSize){
        //作用为toIndex最后没有toIndex条数据则剩余几条newList中就装几条
        toIndex=listSize-i;
        }
        List<ArchiveFarmPatrolledRecordDuringTag> insertBatchList=tagList.subList(i,i+toIndex);

        this.insertBatch(insertBatchList);
        }

```
### 使用了一次递归

```java
        private List<GisLandType> getLandTyeList(Integer startIndex,Integer pageSize,String areaId ) {
        //先查询当前区域，如果当前区域没有数据，则向上查询，有数据则直接返回
        List<GisLandType> list = gisLandTypeManage.getListByAreaIdAndPage(areaId, startIndex, pageSize);
        if (list.size() == 0) {
        //查询父区域id，查询父区域关联地块用途信息
        BaseResp<Area> parentAreaByIdAndLevel = areaFacadeClient.getParentAreaByIdAndLevel(areaId);
        if (parentAreaByIdAndLevel.isSuccess() && parentAreaByIdAndLevel.getObj() != null) {
        log.info("查询区域parent信息成功{}",parentAreaByIdAndLevel.getObj());
        Area area = parentAreaByIdAndLevel.getObj();
        if (area.getLevel() > 0) {
        list.addAll(this.getLandTyeList(startIndex, pageSize, area.getId()));
        }
        }
        return list;
        }else {
        return list;
        }
        }
```