# effectiveJava笔记

  * [**1.引言**](#1.引言)
  * [**2.创建和销毁对象**](#2.创建和销毁对象)
  * [**3.对所有对象都通用的方法**](#3.对所有对象都通用的方法)
  * [**4.类和接口**](#4.类和接口)
  * [**5.泛型**](#5.泛型)
  * [**6.枚举和注解**](#6.枚举和注解)
  * [**7.函数式和流**](#7.函数式和流)
  * [**8.方法**](#8.方法)
  * [**9.通用编程**](#9.通用编程)
  * [**10.异常**](#10.异常)
  * [**11.并发**](#11.并发)
  * [**12.序列化**](#12.序列化)



## 1.引言
- 代码应该被重用，而不是被拷贝
- Java 语言支持四种类型：接口 (包括注解）、类（包括 enum)、数组和基本类型 前3种类型通常被称为引用类型(reference type)，类实例和数组是对象(object)，而基本类型值不是对象，类成员由它的域
  ( field)、方法(method 成员类 member class)和成员接口(member interface)组成；
-  方法的签名(signature 由它的名称和所有参数类型组成；签名不包括方法的返回类型）; 
    - **注：联想到构成方法重载的约束**
- **类、接口、构造器、成员以及序列化形式被统称为API元素(API element) 。API由所有可在定义该API的包之外访问的API元素组成。**
     
     
## 2.创建和销毁对象
1. 用静态工厂方法代替构造器；
    - 当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且仔细地选择名称以便突出静态工厂方法之间的区别。  **联想统一结果返回的包装类的静态工厂方法，易使用**
    - 静态工厂方法与构造器不同的第三大优势在子，它们可以返回原返回类型的任何子类型的对象；
    - 服务提供者框架是指这样一个系统：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解稠出来。
      服务提供者框架中有三个重要的组件：服务接口(Service Interface)，这是提供者实现的；提供者注册API ( Provider Registration API)，这是提供者用来注册实现的；服务访问API (Service Access API) ，这是客户端用来获取服务的实例。服务访问API 是客户端用来指定某种选择实现的条件。如果没有这样的规定， API 就会返回默认实现的一个实例，或者允许客户端遍历所有可用的实现。
    - 缺点
        - 静态工厂方法的主要缺点在子，类如果不含公有的或者受保护的构造器，就不能被子类化。
        - 静态工厂方法的第二个缺点在于，程序员很难发现它们。
            - from一一类型转换方法，它只有单个参数，返回该类型的一个相对应的实例
            - of 聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来
            - valueOf一比from 和of 更烦琐的一种替代方法
            - instance 或者get Instance-－返回的实例是通过方法的（如有）参数来描述的
            - create 或者new工nstance一才象instance 或者getinstaηce 一样，但create或者newXXX 能够确保每次调用都返回一个新的实例
            - getType一像get Instance 一样，但是在工厂方法处于不同的类中的时－候使用。Type表示工厂方法所返回的对象类型，例如：FileStore fs = Files.getFileStore(path);
            - newType一像newInstance 一样，，但是在工厂方法处于不同的类中的时候使用。
            
2. 遇到多个构造器参数时要考虑使用构建器        
    - 多重叠构造器的安全性、**javaBeans分部构建实例缺乏安全性**
    - 由于只有当类不包含显式的构造器时，编译器才会生成缺省的构造器，因此只要让这个类**包含一个私有构造器**，它就不能被实例化。
```java
    //Noninstantiable utility class
    public class UtilLityClass {
    
        private UtilLityClass() {
            throw new AssertionError();
        }
        //...
    }
```
- 
  - 除了重用不可变的对象之外，也可以重用那些已知不会被修改的可变对象。
  - 正则表达式优化：先创建一个final pattern，复用
```java
    public class RomanNumerals {

        private final static Pattern ROMAN = Pattern.compile("xxx---xxx---xxxx");
        public static isRomanNumeral(String s) {
            return ROMAN.matcher(s).matches();
        }

    }
  
```
- 
    - 注意，在提倡使用**保护性拷贝**的时候，因重用对象而付出的代价要远远大于因创建重复对象而付出的代价。必要时如果没能实施保护性拷贝，将会导致潜在的Bug 和安全漏洞；而不必要地创建对象则只会影响程序的风格和性能。
    - 内存泄漏
        - 在极端的情况下，这种内存泄漏会导致磁盘交换(Disk Paging)，甚至导致程序失败(OutOfMemoryError 错误
        - 只要类是自己管理内存，程序员就应该警惕内存泄漏问题;
        - 内存泄漏的另一个常见来源是缓存;
        - 内存泄漏的第三个常见来源是监昕器和其他回调。
            - 确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用(weakreference) ，例如，只将它们保存成WeakHashMap 中的键。

- 避免使用终结方法和清除方法
    - 从一个对象变得不可达开始，到它的终结方法被执行，所花费的这段时间是任意长的。这意味着， 注重时间(time-c「itical l 的任务不应该由终结方法或者清除方法来完成。
    - 使用终结方法的另一个问题是：如果忽略在终结过程中被抛出来的未被捕获的异常，该对象的终结过程也会终止［ JLS, 12 . 6 ］
    
    - **终结方法有一个严重的安全问题： 它们为终结方法攻击(finalizer attack) 打开了类的大门。终结方法攻击背后的思想很简单：如果从构造器或者它的序列化对等体(readObject和readResolve 方法，详见第12 章）抛出异常，恶意子类的终结方法就可以在构造了一部分的应该已经半途夭折的对象上运行。这个终结方法会将对该对象的引用记录在一个静态域中，阻止它被垃圾回收。一旦记录到异常的对象，就可以轻松地在这个对象上调用任何原本永远不允许在这里出现的方法。从构造器抛出的异常，应该足以防止对象继续存在；有了终结方法的存在，这一点就做不到了。这种攻击可能造成致命的后果。fina l 类不会受到终结方法攻击，因为没有人能够编写出final 类的恶意子类。为了防止非final 类受到终结方法攻击， 要编写一个空的final 的finalize 方法。** 
    - **没看懂**
    - 那么，如果类的对象中封装的资源（例如文件或者线程）确实需要终止，应该怎么做才能不用编写终结方法或者清除方法呢？只需让类实现AutoCloseable，并要求其客户端在每个实例不再需要的时候调用close 方法，一般是利用try - with - resources 确保终止，即使遇到异常也是如此（详见第9 条） 。



    
## 3.对所有对象都通用的方法



## 4.类和接口
## 5.泛型
## 6.枚举和注解
## 7.函数式和流
## 8.方法
## 9.通用编程
## 10.异常
## 11.并发
## 12.序列化